import os
import csv
import json
import numpy as np
import joblib as jb
from box import Box
import xgboost as xgb
from sklearn import svm
from sklearn.model_selection import train_test_split
from sklearn.metrics import precision_score, recall_score, accuracy_score

from Logger import setup_logger
from utils import Vectorize, Extraction

class MalwareDetector():
    '''
    Model for malware detection.
    This class handles data extraction, vectorization, training, and prediction.
    '''
    
    def __init__(self, config_path="./config.json"):
        '''
        Initializes the model.
        '''
        # Read config.json
        with open(config_path) as f:
            self.config = Box(json.load(f))
            
        if hasattr(self.config, "config"):
            self.train_files = {f["filename"]: f["label"] for f in self.config.label if f["tags"] == "train"}
            self.test_files = {f["filename"]: f["label"] for f in self.config.label if f["tags"] == "test"}
            self.predict_files = {f["filename"]: f["label"] for f in self.config.label if f["tags"] == "predict"}
            self.config = self.config.config
        else:
            self.train_files = {}
            self.test_files = {}
            self.predict_files = {}
            with open(self.config.path.input_file, mode='r') as file:
                csv_reader = csv.DictReader(file)
                for row in csv_reader:
                    if row['tags'] == "train":
                        self.train_files[row['filename']] = row['label']
                    elif row['tags'] == "test":
                        self.test_files[row['filename']] = row['label']
                    elif row['tags'] == "predict":
                        self.predict_files[row['filename']] = row['label']
                    else:
                        raise ValueError(f"Invalid tag: {row['tags']}")
        
        # Create necessary directories
        for folder_name, folder_path in self.config.folder.items():
            os.makedirs(folder_path, exist_ok=True)
        
        # Set up logging system
        self.logger = setup_logger(logger_name=self.config.model.model_name, logging_config_path=self.config.path.logging_config, output_log_path=self.config.path.log_file)
        self.logger.info(self.config.model.model_name + "model initialized")
        
        # Initialize model
        if self.config.model.model_name == "SVM":
            self.detector = svm.SVC(kernel=self.config.model.kernel_type, probability=self.config.model.probability)
        elif self.config.model.model_name == "XGBoost":
            self.detector = xgb.XGBClassifier(n_estimators=self.config.model.n_estimators, max_depth=self.config.model.max_depth, eta=self.config.model.learning_rate,
                                        eval_metric=self.config.model.eval_metric, use_label_encoder=self.config.model.use_label_encoder)
        else:
            raise ValueError(f"Invalid model name: {self.config.model.model_name}")
        
    def extractFeature(self, filename=None):
        '''
        Extracts features from the malware dataset.
        
        Parameters:
        filename (str): Path to the file to extract features from (default: None, using self.file_list).

        Returns:
        list: A list of extracted features from the dataset(s).
        '''
        if filename is not None:
            self.logger.info(f"Extracting features")
            return Extraction(filename)
        
        if hasattr(self, "file_list"):
            self.logger.info(f"Extracting features from file_list")
            return [Extraction(f) for f in self.file_list.keys()]
        else:
            self.logger.info(f"self.file_list not found. Extracting features from train, test, and predict files")
            file_list = self.train_files.keys() + self.test_files.keys() + self.predict_files.keys()
            return [Extraction(f) for f in file_list]
    
    def vectorize(self, sequence):
        '''
        Vectorizes the extracted features into a numpy array.
        
        Parameters:
        sequence (list): List of extracted features.

        Returns:
        numpy array: Vectorized form of the extracted features.
        '''
        self.logger.info("Vectorizing extracted features")
        return Vectorize(sequence, self.config.path.top_features)
    
    def model(self, training=True):
        '''
        Trains or loads the model.
        
        Parameters:
        training (bool): Whether to train the model (default: True) (False: Load or save model)

        Returns:
        None
        '''
        if self.config.path.input_model:
            self.logger.info(f"Loading model from {self.config.path.input_model}")
            self.load_model(self.config.path.input_model)
        
        if training:
            self.logger.info(f"Training model")
            
            # Load training data
            self.file_list = self.train_files
            train_samples = self.extractFeature()
            X_train = np.vstack([self.vectorize(s) for s in train_samples])
            y_train = [1 if label == "benignware" else 0 for label in self.train_files.values()]
            
            # Load testing data
            self.file_list = self.test_files
            test_samples = self.extractFeature()
            X_test = np.vstack([self.vectorize(s) for s in test_samples])
            y_test = [1 if label == "benignware" else 0 for label in self.test_files.values()]
            
            self.detector.fit(X_train, y_train)
            
            y_pred = self.detector.predict(X_test)
            
            precision = precision_score(y_test, y_pred)
            recall = recall_score(y_test, y_pred)
            accuracy = accuracy_score(y_test, y_pred)
            
            self.logger.info(f"Precision: {precision:.2f}")
            self.logger.info(f"Recall: {recall:.2f}")
            self.logger.info(f"Accuracy: {accuracy:.2f}")
            
            # Save training results to score.json
            if self.config.path.train_result != "" and self.config.path.train_result is not None:
                y_test = np.array(y_test)
                y_pred = np.array(y_pred)
                training_results = {
                    "final_result": {
                        "TP": int((y_test & y_pred).sum()),
                        "TN": int(((1 - y_test) & (1 - y_pred)).sum()),
                        "FP": int(((1 - y_test) & y_pred).sum()),
                        "FN": int((y_test & (1 - y_pred)).sum()),
                        "accuracy": accuracy,
                        "precision": precision,
                        "recall": recall,
                        "f1_score": 0 if precision + recall == 0 else 2 * (precision * recall) / (precision + recall)
                    }
                }
                with open(self.config.path.train_result, 'w') as f:
                    json.dump(training_results, f, indent=4)
            
        if self.config.path.output_model:
            self.save_model(self.config.path.output_model)
    
    def predict(self):
        '''
        Predicts whether the given files are malware or benignware.
        
        Returns:
        list: A list of dictionaries containing the file name and detection result.
        '''
        self.logger.info(f"Predicting")
        results = []
        
        for filename in self.predict_files.keys():
            self.logger.info(f"Processing {filename}")
            sequence = self.extractFeature(filename)
            X_sample = self.vectorize(sequence)
            prediction = self.detector.predict(X_sample)
            label = "benignware" if prediction[0] == 1 else "malware"
            results.append({"name": filename, "detection": label})
            
        if self.config.path.predict_result:
            self.logger.info(f"Saving results to {self.config.path.predict_result}")
            with open(self.config.path.predict_result, mode='w') as file:
                json.dump(results, file, indent=4)
        
        return results
    
    def save_model(self, output_model_path):
        '''
        Saves the trained model to a file.
        '''
        self.logger.info(f"Saving model to {output_model_path}")
        jb.dump(self.detector, output_model_path)
    
    def load_model(self, input_model_path):
        '''
        Loads a pre-trained model from a file.
        '''
        self.logger.info(f"Loading model from {input_model_path}")
        self.detector = jb.load(input_model_path)
        
if __name__ == "__main__":
    # config_path = "./src/config/config_SVM.json"
    config_path = "./src/config/config_XGBoost.json"
    model = MalwareDetector(config_path)
    model.model(training=True)
    model.predict()
