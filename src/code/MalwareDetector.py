import os
import csv
import json
import numpy as np
import joblib as jb
from box import Box
import xgboost as xgb
from sklearn import svm
from sklearn.model_selection import train_test_split
from sklearn.metrics import precision_score, recall_score, accuracy_score

from Logger import setup_logger
from utils import Vectorize, Extraction

class MalwareDetector():
    '''
    Model for malware detection.
    This class handles data extraction, vectorization, training, and prediction.
    '''
    
    def __init__(self, config_path="./config.json"):
        '''
        Initializes the model.
        '''
        # Read config.json
        with open(config_path) as f:
            self.config = Box(json.load(f))
            
        if hasattr(self.config, "config"):
            self.file_list = {f["filename"]: f["label"] for f in self.config.label}
            self.config = self.config.config
        else:
            self.file_list = {}
            with open(self.config.path.input_file, mode='r') as file:
                csv_reader = csv.DictReader(file)
                for row in csv_reader:
                    self.file_list[row['filename']] = row['label']
        
        # Create necessary directories
        for folder_name, folder_path in self.config.folder.items():
            os.makedirs(folder_path, exist_ok=True)
        
        # Set up logging system
        self.logger = setup_logger(logger_name=self.config.model.model_name, logging_config_path=self.config.path.logging_config, output_log_path=self.config.path.log_file)
        self.logger.info(self.config.model.model_name, "model initialized")
        
        # Initialize model
        if self.config.model.model_name == "SVM":
            self.detector = svm.SVC(kernel=self.config.model.kernel_type, probability=self.config.model.probability)
        elif self.config.model.model_name == "XGBoost":
            self.detector = xgb.XGBClassifier(n_estimators=self.config.model.n_estimators, max_depth=self.config.model.max_depth, eta=self.config.model.learning_rate,
                                        eval_metric=self.config.model.eval_metric, use_label_encoder=self.config.model.use_label_encoder)
        else:
            raise ValueError(f"Invalid model name: {self.config.model.model_name}")
        
    def extractFeature(self, filename=None):
        '''
        Extracts features from the malware dataset.
        
        Parameters:
        filename (str): Path to the file to extract features from (default: None, using file_list from config).

        Returns:
        list: A list of extracted features from the dataset(s).
        '''
        if filename is not None:
            self.logger.info(f"Extracting features")
            return Extraction(filename)
        
        self.logger.info(f"Extracting features from config file_list")
        return [Extraction(f) for f in self.file_list.keys()]
    
    def vectorize(self, sequence):
        '''
        Vectorizes the extracted features into a numpy array.
        
        Parameters:
        sequence (list): List of extracted features.

        Returns:
        numpy array: Vectorized form of the extracted features.
        '''
        self.logger.info("Vectorizing extracted features")
        return Vectorize(sequence, self.config.path.top_features)
        
    def load_data(self, file_list=None):
        '''
        Loads and processes data from a list of file paths.
        
        Parameters:
        file_list (list): List of file paths to be used for training or prediction.(default: None, using file_list from config)

        Returns:
        tuple: A tuple containing:
            - numpy array of vectorized features.
            - numpy array of corresponding labels (0 for malware, 1 for benignware).
        '''
        if file_list is None:
            file_list = self.file_list.keys()
            self.logger.info(f"Loading data from config file_list")
        else:
            self.logger.info(f"Loading data from parameter")
        
        samples = self.extractFeature()
        vectorized_samples = np.vstack([self.vectorize(s) for s in samples])
        labels = [1 if label == "benignware" else 0 for label in self.file_list.values()]
        
        return vectorized_samples, np.array(labels)
    
    def model(self, training=True):
        '''
        Trains or loads the model.
        
        Parameters:
        training (bool): Whether to train the model (default: True) (False: Load or save model)

        Returns:
        None
        '''
        if self.config.path.input_model:
            self.logger.info(f"Loading model from {self.config.path.input_model}")
            self.load_model(self.config.path.input_model)
        
        if training:
            self.logger.info(f"Training model")
            X, y = self.load_data()
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=self.config.model.test_size, random_state=self.config.model.random_state)
            
            self.detector.fit(X_train, y_train)
            
            y_pred = self.detector.predict(X_test)
            
            precision = precision_score(y_test, y_pred)
            recall = recall_score(y_test, y_pred)
            accuracy = accuracy_score(y_test, y_pred)
            
            self.logger.info(f"Precision: {precision:.2f}")
            self.logger.info(f"Recall: {recall:.2f}")
            self.logger.info(f"Accuracy: {accuracy:.2f}")
            
            # Save training results to score.json
            if self.config.path.train_result != "" and self.config.path.train_result is not None:
                training_results = {
                    "final_result": {
                        "TP": int((y_test & y_pred).sum()),
                        "TN": int(((1 - y_test) & (1 - y_pred)).sum()),
                        "FP": int(((1 - y_test) & y_pred).sum()),
                        "FN": int((y_test & (1 - y_pred)).sum()),
                        "accuracy": accuracy,
                        "precision": precision,
                        "recall": recall,
                        "f1_score": 0 if precision + recall == 0 else 2 * (precision * recall) / (precision + recall)
                    }
                }
                with open(self.config.path.train_result, 'w') as f:
                    json.dump(training_results, f, indent=4)
            
        if self.config.path.output_model:
            self.save_model(self.config.path.output_model)
    
    def predict(self):
        '''
        Predicts whether the given files are malware or benignware.
        
        Returns:
        list: A list of dictionaries containing the file name and detection result.
        '''
        self.logger.info(f"Predicting")
        results = []
        
        for filename in self.file_list.keys():
            self.logger.info(f"Processing {filename}")
            sequence = self.extractFeature(filename)
            X_sample = self.vectorize(sequence)
            prediction = self.detector.predict(X_sample)
            label = "benignware" if prediction[0] == 1 else "malware"
            results.append({"name": filename, "detection": label})
            
        if self.config.path.predict_result:
            self.logger.info(f"Saving results to {self.config.path.predict_result}")
            with open(self.config.path.predict_result, mode='w') as file:
                json.dump(results, file, indent=4)
        
        return results
    
    def save_model(self, output_model_path):
        '''
        Saves the trained model to a file.
        '''
        self.logger.info(f"Saving model to {output_model_path}")
        jb.dump(self.detector, output_model_path)
    
    def load_model(self, input_model_path):
        '''
        Loads a pre-trained model from a file.
        '''
        self.logger.info(f"Loading model from {input_model_path}")
        self.detector = jb.load(input_model_path)
        
if __name__ == "__main__":
    # config_path = "./src/config/config_SVM.json"
    config_path = "./src/config/config_XGBoost.json"
    model = MalwareDetector(config_path)
    model.model(training=True)
    model.predict()
